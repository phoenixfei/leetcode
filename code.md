# Java、Python代码笔记
# Java
### 队列、堆栈
[队列](http://www.runoob.com/java/data-queue.html)是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。  
LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。   
[栈Stack](http://www.runoob.com/java/java-stack-class.html)是Vector的一个子类，它实现了一个标准的后进先出的栈。

### 堆栈内存
Java把内存分成两种，一种叫做栈内存，一种叫做堆内存

在函数中定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。

堆内存用于存放由new创建的对象和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。

引用变量是普通变量，定义时在栈中分配内存，引用变量在程序运行到作用域外释放。而数组＆对象本身在堆中分配，即使程序运行到使用new产生数组和对象的语句所在地代码块之外，数组和对象本身占用的堆内存也不会被释放，数组和对象在没有引用变量指向它的时候，才变成垃圾，不能再被使用，但是仍然占着内存，在随后的一个不确定的时间被垃圾回收器释放掉。这个也是java比较占内存的主要原因，实际上，栈中的变量指向堆内存中的变量，这就是 Java 中的指针!

# 树
## 1. 遍历  
[先序、中序、后序遍历](https://www.jianshu.com/p/456af5480cee)  
先序：考察到一个节点后，即刻输出该节点的值，并继续遍历其左右子树。(根左右)  
中序：考察到一个节点后，将其暂存，遍历完左子树后，再输出该节点的值，然后遍历右子树。(左根右)  
后序：考察到一个节点后，将其暂存，遍历完左右子树后，再输出该节点的值。(左右根)  
Tips：无论先序、中序、后序，对节点的考查（不一定输出）顺序都是一样的。

# [十大经典排序算法](https://www.cnblogs.com/onepixel/articles/7674659.html)
**相关概念**：
稳定与不稳定，指如果a=b，a原本在b前面，排序后仍在，视为稳定，反之。。。  
时间复杂度：对排序数据的总操作次数；  
空间复杂度：指算法在计算机内执行所需存储空间的度量。  
1. 冒泡排序
依次比较两个相邻的元素，如果它们大小相反，则将它们位置换过来，这样，最大或者最小的元素就会浮动到两端。注意，从小到大排序，顺序遍历即可；从大到小排序，要逆序遍历。O(n2)/O(1)  
2. 选择排序
首先从未排序的数组中选出最大/最小的元素，存放到数组的起始位置；然后，从未排序的数组中选出此时最大/最小元素，放入已排序的末尾。。。O(n2)/O(1)  
3. 插入排序
从第二个元素开始（视第一个以排序），依次比较与已排序数组各元素的大小，确定该元素正确插入位置。。。O(n2)/O(1)  
4. 希尔排序  
1959年Shell发明，第一个突破O(n2)的排序算法，是简单插入排序的改进版。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又称 递减增量排序。  
5. 归并排序
该算法采用**分治法**，先将序列划分为子序列，进行排序；再将已有序的子序列合并，得到完全有序的序列
6. 快速排序
选取一个基准，将小于基准的放左边、大于基准的放右边；对基准左右两边的子串重新进行排序，重复第一步，基准不参与排序；直至子串长度为1，结束递归